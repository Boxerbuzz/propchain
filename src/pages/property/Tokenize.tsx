import React, { useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { supabaseService } from "@/services/supabaseService";
import { toast } from "sonner";
import { useAuth } from "@/context/AuthContext";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  HoverCard,
  HoverCardContent,
  HoverCardTrigger,
} from "@/components/ui/hover-card";
import { Progress } from "@/components/ui/progress";
import { Separator } from "@/components/ui/separator";
import MoneyInput from "@/components/ui/money-input";
import TokenizationTermsAcceptance from "@/components/TokenizationTermsAcceptance";
import { FundAllocationBuilder, FundAllocation } from "@/components/FundAllocationBuilder";
import { UseOfFundsChart } from "@/components/UseOfFundsChart";
import {
  ArrowLeft,
  Building,
  Banknote,
  TrendingUp,
  Info,
  ChevronLeft,
  ChevronRight,
  AlertTriangle,
  DollarSign,
} from "lucide-react";

// Tokenization types
type TokenizationType = "equity" | "debt" | "revenue";

interface TokenizationTypeOption {
  id: TokenizationType;
  title: string;
  description: string;
  icon: React.ComponentType<any>;
  badge: string;
  details: {
    structure: string;
    returns: string;
    risk: string;
    rights: string;
    example: string;
    maxRaise: string;
  };
}

const tokenizationTypes: TokenizationTypeOption[] = [
  {
    id: "equity",
    title: "Equity-Based Tokenization",
    description: "Fractional ownership of the property",
    icon: Building,
    badge: "Ownership",
    details: {
      structure: "Tokens represent actual shares/ownership of the property",
      returns: "Capital appreciation + proportional rental income/profits",
      risk: "Higher risk, higher potential reward",
      rights: "Voting rights on property decisions, ownership benefits",
      example:
        "Own 1% of property â†’ get 1% of rental income + 1% of sale proceeds",
      maxRaise: "Maximum raise equals property appraised value",
    },
  },
  {
    id: "debt",
    title: "Debt-Based Tokenization",
    description: "Real estate-backed debt instrument",
    icon: Banknote,
    badge: "Lending",
    details: {
      structure: "Tokens represent loans to the property owner/developer",
      returns: "Fixed interest rate payments over time",
      risk: "Lower risk, predictable returns with LTV protection",
      rights: "Priority in repayment, no ownership or voting rights",
      example: "Lend at 8% annual interest with 70% LTV ratio protection",
      maxRaise: "Raise can be 70-80% of property value (LTV ratio)",
    },
  },
  {
    id: "revenue",
    title: "Revenue-Sharing Tokenization",
    description: "Share in property revenue streams",
    icon: TrendingUp,
    badge: "Revenue",
    details: {
      structure: "Tokens provide share of gross rental income/revenues",
      returns: "Percentage of property revenues (not profits)",
      risk: "Medium risk, income-focused without ownership",
      rights: "Revenue sharing without ownership obligations",
      example: "Receive 5% of all rental income generated by property",
      maxRaise: "Based on expected future cashflows (NPV/IRR models)",
    },
  },
];

const createTokenizationSchema = (propertyValue: number) =>
  z
    .object({
      tokenization_type: z.enum(["equity", "debt", "revenue"]),
      token_name: z.string().min(1, "Token name is required"),
      token_symbol: z
        .string()
        .min(2, "Token symbol must be at least 2 characters")
        .max(10, "Token symbol must be at most 10 characters"),
      total_supply: z
        .number()
        .min(1000, "Minimum total supply is 1,000 tokens"),
      price_per_token: z
        .number()
        .min(0.01, "Price per token must be at least 0.01"),
      min_investment: z.number().min(1, "Minimum investment is required"),
      max_investment: z.number().optional(),
      min_tokens_per_purchase: z.number().int().min(1).optional(),
      max_tokens_per_purchase: z.number().int().min(1).optional(),
      target_raise: z.number().min(1, "Target raise is required"),
      minimum_raise: z.number().min(1, "Minimum raise is required"),
      investment_window_days: z
        .number()
        .min(1, "Investment window must be at least 1 day")
        .max(365, "Investment window cannot exceed 365 days"),
      expected_roi_annual: z.number().min(0).max(100).optional(),
      dividend_frequency: z
        .enum(["monthly", "quarterly", "annually"])
        .optional(),
      management_fee_percentage: z.number().min(0).max(10).optional(),
      platform_fee_percentage: z.number().min(0).max(5).optional(),
      auto_refund: z.boolean().optional(),
    })
    .refine(
      (data) => {
        const maxPossibleRaise = data.total_supply * data.price_per_token;
        return data.target_raise <= maxPossibleRaise;
      },
      {
        message: "Target raise cannot exceed total supply Ã— price per token",
        path: ["target_raise"],
      }
    )
    .refine(
      (data) => {
        return data.minimum_raise < data.target_raise;
      },
      {
        message: "Minimum raise must be less than target raise",
        path: ["minimum_raise"],
      }
    )
    .refine(
      (data) => {
        if (data.tokenization_type === "equity") {
          return data.target_raise <= propertyValue;
        } else if (data.tokenization_type === "debt") {
          const maxDebtRaise = propertyValue * 0.8;
          return data.target_raise <= maxDebtRaise;
        }
        return true;
      },
      {
        message:
          "Target raise exceeds the allowed limit for this tokenization type",
        path: ["target_raise"],
      }
    )
    .refine(
      (data) => {
        const maxPossibleRaise = data.total_supply * data.price_per_token;
        
        if (data.tokenization_type === "equity") {
          return maxPossibleRaise <= propertyValue;
        } else if (data.tokenization_type === "debt") {
          const maxDebtValue = propertyValue * 0.8;
          return maxPossibleRaise <= maxDebtValue;
        } else if (data.tokenization_type === "revenue") {
          const maxRevenueValue = propertyValue * 2;
          return maxPossibleRaise <= maxRevenueValue;
        }
        return true;
      },
      {
        message: "Total token value (supply Ã— price) exceeds the allowed limit for this tokenization type",
        path: ["total_supply"],
      }
    )
    .refine(
      (data) => {
        if (data.max_investment) {
          return data.max_investment >= data.min_investment;
        }
        return true;
      },
      {
        message: "Maximum investment must be greater than or equal to minimum investment",
        path: ["max_investment"],
      }
    );

type TokenizationForm = z.infer<ReturnType<typeof createTokenizationSchema>>;

const TokenizeProperty = () => {
  const { propertyId } = useParams<{ propertyId: string }>();
  const navigate = useNavigate();
  const { user, isAuthenticated } = useAuth();
  const queryClient = useQueryClient();

  const [step, setStep] = useState(0);
  const [selectedType, setSelectedType] = useState<TokenizationType>("equity");
  const [useOfFunds, setUseOfFunds] = useState<FundAllocation[]>([]);

  // Fetch property details
  const { data: property, isLoading: propertyLoading } = useQuery({
    queryKey: ["property", propertyId],
    queryFn: () => supabaseService.properties.getPropertyById(propertyId!),
    enabled: !!propertyId,
  });

  const form = useForm<TokenizationForm>({
    resolver: zodResolver(
      createTokenizationSchema(property?.estimated_value || 0)
    ),
    defaultValues: {
      tokenization_type: "equity" as TokenizationType,
      token_name: property ? `${property.title} Token` : "",
      token_symbol: property
        ? property.title
            .substring(0, 6)
            .toUpperCase()
            .replace(/[^A-Z]/g, "")
        : "",
      total_supply: 10000,
      price_per_token: 100,
      min_investment: 10000,
      max_investment: 1000000,
      target_raise: property
        ? Math.min(
            Math.floor((property.estimated_value || 0) * 0.8),
            property.estimated_value || 0
          )
        : 0,
      minimum_raise: property
        ? Math.floor((property.estimated_value || 0) * 0.3)
        : 0,
      min_tokens_per_purchase: 1,
      max_tokens_per_purchase: 1000,
      investment_window_days: 30,
      expected_roi_annual: 8,
      dividend_frequency: "quarterly",
      management_fee_percentage: 2.5,
      platform_fee_percentage: 1.0,
      auto_refund: true,
    },
  });

  const totalSupply = form.watch("total_supply");
  const pricePerToken = form.watch("price_per_token");
  const targetRaise = form.watch("target_raise");
  const maxPossibleRaise =
    totalSupply && pricePerToken ? totalSupply * pricePerToken : 0;

  const createTokenizationMutation = useMutation({
    mutationFn: async (data: TokenizationForm) => {
      if (!isAuthenticated || !user?.id) {
        throw new Error("You must be logged in to tokenize a property.");
      }
      if (!property || property.owner_id !== user.id) {
        throw new Error("You can only tokenize properties you own.");
      }

      const {
        investment_window_days,
        max_investment,
        expected_roi_annual,
        dividend_frequency,
        management_fee_percentage,
        platform_fee_percentage,
        auto_refund,
        tokenization_type,
        ...rest
      } = data;

      const now = new Date();
      const investment_window_start = now.toISOString();
      const investment_window_end = new Date(
        now.getTime() + investment_window_days * 24 * 60 * 60 * 1000
      ).toISOString();

      const selectedTypeInfo = tokenizationTypes.find(
        (t) => t.id === tokenization_type
      );
      const payload = {
        property_id: property.id,
        tokenization_type: tokenization_type,
        token_name: `${String(rest.token_name).trim()} (${
          selectedTypeInfo?.badge
        })`,
        token_symbol: String(rest.token_symbol).trim().toUpperCase(),
        total_supply: rest.total_supply,
        price_per_token: rest.price_per_token,
        min_investment: rest.min_investment,
        max_investment: max_investment || null,
        min_tokens_per_purchase: rest.min_tokens_per_purchase || null,
        max_tokens_per_purchase: rest.max_tokens_per_purchase || null,
        target_raise: rest.target_raise,
        minimum_raise: rest.minimum_raise,
        investment_window_start,
        investment_window_end,
        expected_roi_annual: expected_roi_annual || null,
        dividend_frequency: dividend_frequency || null,
        management_fee_percentage: management_fee_percentage || null,
        platform_fee_percentage: platform_fee_percentage || null,
        auto_refund: auto_refund ?? true,
        status: "draft",
        use_of_funds: useOfFunds,
      };

      return supabaseService.tokenizations.create(payload);
    },
    onSuccess: () => {
      toast.success("Tokenization created successfully");
      queryClient.invalidateQueries({ queryKey: ["property", propertyId] });
      navigate("/property/management");
    },
    onError: (error: any) => {
      const details = error?.details || error?.message || "Unknown error";
      const hint = error?.hint ? ` ${error.hint}` : "";
      const code = error?.code ? ` [${error.code}]` : "";
      toast.error(`Failed to create tokenization: ${details}${hint}${code}`);
    },
  });

  const handleTermsAccept = () => {
    form.handleSubmit(onSubmit)();
  };

  const handleTermsDecline = () => {
    setStep(2);
  };

  const handleTypeSelection = (type: TokenizationType) => {
    setSelectedType(type);
    form.setValue("tokenization_type", type);

    // Set type-specific default values
    if (type === "equity") {
      form.setValue(
        "target_raise",
        property ? Math.floor(property.estimated_value * 0.8) : 0
      );
      form.setValue(
        "minimum_raise",
        property ? Math.floor(property.estimated_value * 0.3) : 0
      );
    } else if (type === "debt") {
      form.setValue(
        "target_raise",
        property ? Math.floor(property.estimated_value * 0.7) : 0
      );
      form.setValue(
        "minimum_raise",
        property ? Math.floor(property.estimated_value * 0.5) : 0
      );
    } else if (type === "revenue") {
      form.setValue(
        "target_raise",
        property ? Math.floor(property.estimated_value * 0.5) : 0
      );
      form.setValue(
        "minimum_raise",
        property ? Math.floor(property.estimated_value * 0.25) : 0
      );
    }

    setStep(1);
  };

  const nextStep = async (e?: React.MouseEvent) => {
    console.log("ðŸ”„ nextStep called, current step:", step);
    
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Step 1 validation
    if (step === 1) {
      const isValid = await form.trigger([
        "token_name",
        "token_symbol",
        "total_supply",
        "price_per_token",
      ]);

      if (isValid) {
        setStep(2);
      }
      return;
    }

    // Step 2 validation - Use of Funds
    if (step === 2) {
      const totalPercentage = useOfFunds.reduce((sum, a) => sum + a.percentage, 0);
      const totalAmount = useOfFunds.reduce((sum, a) => sum + a.amount_ngn, 0);

      if (useOfFunds.length === 0) {
        toast.error("Please add at least one fund allocation category");
        return;
      }

      if (Math.abs(totalPercentage - 100) >= 0.01) {
        toast.error("Total allocation must equal 100%");
        return;
      }

      if (Math.abs(totalAmount - targetRaise) >= 1) {
        toast.error(`Total amount must equal â‚¦${targetRaise.toLocaleString()}`);
        return;
      }

      setStep(3);
      return;
    }
  };

  const prevStep = () => {
    if (step === 1) {
      setStep(0);
    } else {
      setStep(step - 1);
    }
  };

  const onSubmit = (data: TokenizationForm) => {
    console.log("ðŸš¨ onSubmit called with step:", step);
    
    if (step !== 3) {
      console.log("ðŸš¨ BLOCKED - not on final step. Current step:", step);
      toast.error(`Cannot submit on step ${step}. Please complete all steps first.`);
      return;
    }
    
    if (!isAuthenticated || !user?.id) {
      toast.error("Please log in to continue.");
      return;
    }
    if (!property || property.owner_id !== user.id) {
      toast.error("You can only tokenize your own property.");
      return;
    }
    
    console.log("ðŸš€ Creating tokenization...");
    createTokenizationMutation.mutate(data);
  };

  if (propertyLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto">
          <div className="animate-pulse space-y-4">
            <div className="h-8 bg-muted rounded w-1/3"></div>
            <div className="h-4 bg-muted rounded w-2/3"></div>
            <div className="h-64 bg-muted rounded"></div>
          </div>
        </div>
      </div>
    );
  }

  if (!property) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto text-center">
          <h1 className="text-2xl font-bold mb-4">Property Not Found</h1>
          <Button onClick={() => navigate("/property/management")}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Properties
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-4xl mx-auto">
        {/* Step indicator */}
        <div className="mb-8">
          <Progress value={(step / 3) * 100} className="h-2" />
          <div className="mt-2 text-sm text-muted-foreground">
            Step {step + 1} of 4
          </div>
        </div>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* Step 0: Type Selection */}
            {step === 0 && (
              <div className="space-y-6">
                <div className="text-center">
                  <h2 className="text-2xl font-bold mb-2">Select Tokenization Type</h2>
                  <p className="text-muted-foreground">
                    Choose how investors will participate in your property
                  </p>
                </div>

                <div className="grid md:grid-cols-3 gap-4">
                  {tokenizationTypes.map((type) => (
                    <Card
                      key={type.id}
                      className={`cursor-pointer transition-all hover:shadow-lg ${
                        selectedType === type.id ? "ring-2 ring-primary" : ""
                      }`}
                      onClick={() => handleTypeSelection(type.id)}
                    >
                      <CardContent className="p-6">
                        <div className="flex flex-col items-center text-center space-y-4">
                          <type.icon className="h-12 w-12 text-primary" />
                          <div>
                            <h3 className="font-semibold">{type.title}</h3>
                            <p className="text-sm text-muted-foreground mt-1">
                              {type.description}
                            </p>
                          </div>
                          <Badge variant="secondary">{type.badge}</Badge>
                        </div>
                      </CardContent>
                    </Card>
                  ))}
                </div>
              </div>
            )}

            {/* Step 1: Basic Information */}
            {step === 1 && (
              <div className="space-y-6">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold mb-2">Basic Token Information</h2>
                  <p className="text-muted-foreground">
                    Configure your token details
                  </p>
                </div>

                <Card>
                  <CardContent className="pt-6 space-y-4">
                    <FormField
                      control={form.control}
                      name="token_name"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Token Name</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="e.g., Luxury Villa Token" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="token_symbol"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Token Symbol</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="e.g., LVILLA" maxLength={10} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="grid grid-cols-2 gap-4">
                      <FormField
                        control={form.control}
                        name="total_supply"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Total Supply</FormLabel>
                            <FormControl>
                              <Input
                                type="number"
                                {...field}
                                onChange={(e) => field.onChange(parseFloat(e.target.value))}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="price_per_token"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Price per Token (â‚¦)</FormLabel>
                            <FormControl>
                              <Input
                                type="number"
                                {...field}
                                onChange={(e) => field.onChange(parseFloat(e.target.value))}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    {maxPossibleRaise > 0 && (
                      <div className="p-4 bg-muted rounded-lg">
                        <p className="text-sm font-medium">
                          Maximum Possible Raise: â‚¦{maxPossibleRaise.toLocaleString()}
                        </p>
                      </div>
                    )}
                  </CardContent>
                </Card>
              </div>
            )}

            {/* Step 2: Use of Funds */}
            {step === 2 && (
              <div className="space-y-6">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold mb-2">Use of Funds</h2>
                  <p className="text-muted-foreground">
                    Specify how the raised funds will be allocated
                  </p>
                </div>

                <FundAllocationBuilder
                  tokenizationType={selectedType}
                  targetRaise={targetRaise || 0}
                  value={useOfFunds}
                  onChange={setUseOfFunds}
                />

                {useOfFunds.length > 0 && (
                  <UseOfFundsChart data={useOfFunds} targetRaise={targetRaise || 0} />
                )}
              </div>
            )}

            {/* Step 3: Terms & Submit */}
            {step === 3 && (
              <TokenizationTermsAcceptance
                tokenizationType={selectedType}
                tokenName={form.watch("token_name")}
                totalSupply={form.watch("total_supply")}
                useOfFunds={useOfFunds}
                targetRaise={targetRaise || 0}
                onAccept={handleTermsAccept}
                onDecline={handleTermsDecline}
                isSubmitting={createTokenizationMutation.isPending}
              />
            )}

            {/* Navigation Buttons */}
            {step < 3 && (
              <div className="flex justify-between">
                {step > 0 && (
                  <Button type="button" variant="outline" onClick={prevStep}>
                    <ChevronLeft className="h-4 w-4 mr-2" />
                    Back
                  </Button>
                )}
                <Button
                  type="button"
                  onClick={nextStep}
                  className={step === 0 ? "ml-auto" : ""}
                >
                  Continue
                  <ChevronRight className="h-4 w-4 ml-2" />
                </Button>
              </div>
            )}
          </form>
        </Form>
      </div>
    </div>
  );
};

export default TokenizeProperty;
