import React, { useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { supabaseService } from "@/services/supabaseService";
import { toast } from "sonner";
import { useAuth } from "@/context/AuthContext";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Switch } from "@/components/ui/switch";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  HoverCard,
  HoverCardContent,
  HoverCardTrigger,
} from "@/components/ui/hover-card";
import { Progress } from "@/components/ui/progress";
import { Separator } from "@/components/ui/separator";
import MoneyInput from "@/components/ui/money-input";
import TokenizationTermsAcceptance from "@/components/TokenizationTermsAcceptance";
import { FundAllocationBuilder, FundAllocation } from "@/components/FundAllocationBuilder";
import { UseOfFundsChart } from "@/components/UseOfFundsChart";
import {
  ArrowLeft,
  Building,
  Banknote,
  TrendingUp,
  Info,
  ChevronLeft,
  ChevronRight,
  AlertTriangle,
  DollarSign,
} from "lucide-react";

// Tokenization types
type TokenizationType = "equity" | "debt" | "revenue";

interface TokenizationTypeOption {
  id: TokenizationType;
  title: string;
  description: string;
  icon: React.ComponentType<any>;
  badge: string;
  details: {
    structure: string;
    returns: string;
    risk: string;
    rights: string;
    example: string;
    maxRaise: string;
  };
}

const tokenizationTypes: TokenizationTypeOption[] = [
  {
    id: "equity",
    title: "Equity-Based Tokenization",
    description: "Fractional ownership of the property",
    icon: Building,
    badge: "Ownership",
    details: {
      structure: "Tokens represent actual shares/ownership of the property",
      returns: "Capital appreciation + proportional rental income/profits",
      risk: "Higher risk, higher potential reward",
      rights: "Voting rights on property decisions, ownership benefits",
      example:
        "Own 1% of property â†’ get 1% of rental income + 1% of sale proceeds",
      maxRaise: "Maximum raise equals property appraised value",
    },
  },
  {
    id: "debt",
    title: "Debt-Based Tokenization",
    description: "Real estate-backed debt instrument",
    icon: Banknote,
    badge: "Lending",
    details: {
      structure: "Tokens represent loans to the property owner/developer",
      returns: "Fixed interest rate payments over time",
      risk: "Lower risk, predictable returns with LTV protection",
      rights: "Priority in repayment, no ownership or voting rights",
      example: "Lend at 8% annual interest with 70% LTV ratio protection",
      maxRaise: "Raise can be 70-80% of property value (LTV ratio)",
    },
  },
  {
    id: "revenue",
    title: "Revenue-Sharing Tokenization",
    description: "Share in property revenue streams",
    icon: TrendingUp,
    badge: "Revenue",
    details: {
      structure: "Tokens provide share of gross rental income/revenues",
      returns: "Percentage of property revenues (not profits)",
      risk: "Medium risk, income-focused without ownership",
      rights: "Revenue sharing without ownership obligations",
      example: "Receive 5% of all rental income generated by property",
      maxRaise: "Based on expected future cashflows (NPV/IRR models)",
    },
  },
];

const createTokenizationSchema = (propertyValue: number) =>
  z
    .object({
      tokenization_type: z.enum(["equity", "debt", "revenue"]),
      token_name: z.string().min(1, "Token name is required"),
      token_symbol: z
        .string()
        .min(2, "Token symbol must be at least 2 characters")
        .max(10, "Token symbol must be at most 10 characters"),
      total_supply: z
        .number()
        .min(1000, "Minimum total supply is 1,000 tokens"),
      price_per_token: z
        .number()
        .min(0.01, "Price per token must be at least 0.01"),
      min_investment: z.number().min(1, "Minimum investment is required"),
      max_investment: z.number().optional(),
      min_tokens_per_purchase: z.number().int().min(1).optional(),
      max_tokens_per_purchase: z.number().int().min(1).optional(),
      target_raise: z.number().min(1, "Target raise is required"),
      minimum_raise: z.number().min(1, "Minimum raise is required"),
      investment_window_days: z
        .number()
        .min(1, "Investment window must be at least 1 day")
        .max(365, "Investment window cannot exceed 365 days"),
      expected_roi_annual: z.number().min(0).max(100).optional(),
      dividend_frequency: z
        .enum(["monthly", "quarterly", "annually"])
        .optional(),
      management_fee_percentage: z.number().min(0).max(10).optional(),
      platform_fee_percentage: z.number().min(0).max(5).optional(),
      auto_refund: z.boolean().optional(),
    })
    .refine(
      (data) => {
        const maxPossibleRaise = data.total_supply * data.price_per_token;
        return data.target_raise <= maxPossibleRaise;
      },
      {
        message: "Target raise cannot exceed total supply Ã— price per token",
        path: ["target_raise"],
      }
    )
    .refine(
      (data) => {
        return data.minimum_raise < data.target_raise;
      },
      {
        message: "Minimum raise must be less than target raise",
        path: ["minimum_raise"],
      }
    )
    .superRefine((data, ctx) => {
      const type = data.tokenization_type;
      const totalTokenValue = data.total_supply * data.price_per_token;

      // Compute per-type limits
      let maxTargetRaise = Infinity;
      let maxTotalTokenValue = Infinity;
      let ruleText = "";

      if (type === "equity") {
        maxTargetRaise = propertyValue;
        maxTotalTokenValue = propertyValue;
        ruleText = "cannot exceed property value";
      } else if (type === "debt") {
        maxTargetRaise = propertyValue * 0.8;
        maxTotalTokenValue = propertyValue * 0.8;
        ruleText = "max 80% Loan-to-Value (LTV)";
      } else if (type === "revenue") {
        // For revenue, we allow token value up to 2Ã— property value as proxy for future cashflows
        maxTargetRaise = Infinity; // no hard cap on target raise here
        maxTotalTokenValue = propertyValue * 2;
        ruleText = "max 2Ã— property value (cashflow proxy)";
      }

      // Target raise vs per-type limit (when finite)
      if (isFinite(maxTargetRaise) && data.target_raise > maxTargetRaise) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Target raise â‚¦${data.target_raise.toLocaleString()} exceeds max â‚¦${Math.floor(maxTargetRaise).toLocaleString()} for ${type} (${ruleText}).`,
          path: ["target_raise"],
        });
      }

      // Total token value vs per-type limit
      if (totalTokenValue > maxTotalTokenValue) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Total token value (supply Ã— price) â‚¦${Math.floor(totalTokenValue).toLocaleString()} exceeds max â‚¦${Math.floor(maxTotalTokenValue).toLocaleString()} for ${type} (${ruleText}).`,
          path: ["total_supply"],
        });
      }
    })
    .refine(
      (data) => {
        if (data.max_investment) {
          return data.max_investment >= data.min_investment;
        }
        return true;
      },
      {
        message: "Maximum investment must be greater than or equal to minimum investment",
        path: ["max_investment"],
      }
    );

type TokenizationForm = z.infer<ReturnType<typeof createTokenizationSchema>>;

const TokenizeProperty = () => {
  const { propertyId } = useParams<{ propertyId: string }>();
  const navigate = useNavigate();
  const { user, isAuthenticated } = useAuth();
  const queryClient = useQueryClient();

  const [step, setStep] = useState(0);
  const [selectedType, setSelectedType] = useState<TokenizationType>("equity");
  const [useOfFunds, setUseOfFunds] = useState<FundAllocation[]>([]);

  // Fetch property details
  const { data: property, isLoading: propertyLoading } = useQuery({
    queryKey: ["property", propertyId],
    queryFn: () => supabaseService.properties.getPropertyById(propertyId!),
    enabled: !!propertyId,
  });

  const form = useForm<TokenizationForm>({
    resolver: zodResolver(
      createTokenizationSchema(property?.estimated_value || 0)
    ),
    defaultValues: {
      tokenization_type: "equity" as TokenizationType,
      token_name: property ? `${property.title} Token` : "",
      token_symbol: property
        ? property.title
            .substring(0, 6)
            .toUpperCase()
            .replace(/[^A-Z]/g, "")
        : "",
      total_supply: 10000,
      price_per_token: 100,
      min_investment: 10000,
      max_investment: 1000000,
      target_raise: property
        ? Math.min(
            Math.floor((property.estimated_value || 0) * 0.8),
            property.estimated_value || 0
          )
        : 0,
      minimum_raise: property
        ? Math.floor((property.estimated_value || 0) * 0.3)
        : 0,
      min_tokens_per_purchase: 1,
      max_tokens_per_purchase: 1000,
      investment_window_days: 30,
      expected_roi_annual: 8,
      dividend_frequency: "quarterly",
      management_fee_percentage: 2.5,
      platform_fee_percentage: 1.0,
      auto_refund: true,
    },
  });

  const totalSupply = form.watch("total_supply");
  const pricePerToken = form.watch("price_per_token");
  const targetRaise = form.watch("target_raise");
  const maxPossibleRaise =
    totalSupply && pricePerToken ? totalSupply * pricePerToken : 0;

  // Auto-calculate target_raise and minimum_raise when total_supply or price_per_token changes
  React.useEffect(() => {
    if (totalSupply && pricePerToken && property) {
      const calculatedMax = totalSupply * pricePerToken;
      
      // Set target_raise to 80% of the max possible raise or type-specific limit, whichever is lower
      let targetPercentage = 0.8;
      if (selectedType === "equity") {
        targetPercentage = Math.min(calculatedMax, property.estimated_value) / calculatedMax;
      } else if (selectedType === "debt") {
        targetPercentage = Math.min(calculatedMax, property.estimated_value * 0.8) / calculatedMax;
      } else if (selectedType === "revenue") {
        targetPercentage = Math.min(calculatedMax, property.estimated_value * 2) / calculatedMax;
      }
      
      const newTargetRaise = Math.floor(calculatedMax * targetPercentage);
      const newMinimumRaise = Math.floor(newTargetRaise * 0.6); // 60% of target
      
      form.setValue("target_raise", newTargetRaise);
      form.setValue("minimum_raise", newMinimumRaise);
    }
  }, [totalSupply, pricePerToken, selectedType, property]);

  const propertyEstValue = property?.estimated_value || 0;
  const typeMaxTotalValue =
    selectedType === "equity"
      ? propertyEstValue
      : selectedType === "debt"
      ? propertyEstValue * 0.8
      : propertyEstValue * 2;
  const typeRuleText =
    selectedType === "equity"
      ? "cannot exceed property value"
      : selectedType === "debt"
      ? "max 80% Loan-to-Value (LTV)"
      : "max 2Ã— property value (cashflow proxy)";


  const createTokenizationMutation = useMutation({
    mutationFn: async (data: TokenizationForm) => {
      if (!isAuthenticated || !user?.id) {
        throw new Error("You must be logged in to tokenize a property.");
      }
      if (!property || property.owner_id !== user.id) {
        throw new Error("You can only tokenize properties you own.");
      }

      const {
        investment_window_days,
        max_investment,
        expected_roi_annual,
        dividend_frequency,
        management_fee_percentage,
        platform_fee_percentage,
        auto_refund,
        tokenization_type,
        ...rest
      } = data;

      const now = new Date();
      const investment_window_start = now.toISOString();
      const investment_window_end = new Date(
        now.getTime() + investment_window_days * 24 * 60 * 60 * 1000
      ).toISOString();

      const selectedTypeInfo = tokenizationTypes.find(
        (t) => t.id === tokenization_type
      );
      const payload = {
        property_id: property.id,
        tokenization_type: tokenization_type,
        token_name: `${String(rest.token_name).trim()} (${
          selectedTypeInfo?.badge
        })`,
        token_symbol: String(rest.token_symbol).trim().toUpperCase(),
        total_supply: rest.total_supply,
        price_per_token: rest.price_per_token,
        min_investment: rest.min_investment,
        max_investment: max_investment || null,
        min_tokens_per_purchase: rest.min_tokens_per_purchase || null,
        max_tokens_per_purchase: rest.max_tokens_per_purchase || null,
        target_raise: rest.target_raise,
        minimum_raise: rest.minimum_raise,
        investment_window_start,
        investment_window_end,
        expected_roi_annual: expected_roi_annual || null,
        dividend_frequency: dividend_frequency || null,
        management_fee_percentage: management_fee_percentage || null,
        platform_fee_percentage: platform_fee_percentage || null,
        auto_refund: auto_refund ?? true,
        status: "draft",
        use_of_funds: useOfFunds,
      };

      return supabaseService.tokenizations.create(payload);
    },
    onSuccess: () => {
      toast.success("Tokenization created successfully");
      queryClient.invalidateQueries({ queryKey: ["property", propertyId] });
      navigate("/property/management");
    },
    onError: (error: any) => {
      const details = error?.details || error?.message || "Unknown error";
      const hint = error?.hint ? ` ${error.hint}` : "";
      const code = error?.code ? ` [${error.code}]` : "";
      toast.error(`Failed to create tokenization: ${details}${hint}${code}`);
    },
  });

  const handleTermsAccept = () => {
    form.handleSubmit(onSubmit)();
  };

  const handleTermsDecline = () => {
    setStep(3);
  };

  const handleTypeSelection = (type: TokenizationType) => {
    setSelectedType(type);
    form.setValue("tokenization_type", type);

    // Set type-specific default values
    if (type === "equity") {
      form.setValue("target_raise", property ? Math.floor(property.estimated_value * 0.8) : 0);
      form.setValue("minimum_raise", property ? Math.floor(property.estimated_value * 0.3) : 0);
      form.setValue("expected_roi_annual", 12);
      form.setValue("dividend_frequency", "quarterly");
      form.setValue("management_fee_percentage", 2.5);
      form.setValue("platform_fee_percentage", 1.0);
    } else if (type === "debt") {
      form.setValue("target_raise", property ? Math.floor(property.estimated_value * 0.7) : 0);
      form.setValue("minimum_raise", property ? Math.floor(property.estimated_value * 0.5) : 0);
      form.setValue("expected_roi_annual", 7);
      form.setValue("dividend_frequency", "monthly");
      form.setValue("management_fee_percentage", 1.5);
      form.setValue("platform_fee_percentage", 1.0);
    } else if (type === "revenue") {
      form.setValue("target_raise", property ? Math.floor(property.estimated_value * 0.5) : 0);
      form.setValue("minimum_raise", property ? Math.floor(property.estimated_value * 0.25) : 0);
      form.setValue("expected_roi_annual", 10);
      form.setValue("dividend_frequency", "monthly");
      form.setValue("management_fee_percentage", 3.0);
      form.setValue("platform_fee_percentage", 1.0);
    }

    // Do NOT auto-advance; wait for user to click Continue
  };

  const nextStep = async (e?: React.MouseEvent) => {
    console.log("ðŸ”„ nextStep called, current step:", step);
    
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Step 0: require a selection before proceeding
    if (step === 0) {
      if (!selectedType) {
        toast.error("Please select a tokenization type to continue");
        return;
      }
      setStep(1);
      return;
    }

    // Step 1 validation - Basic Token Info
    if (step === 1) {
      const isValid = await form.trigger([
        "token_name",
        "token_symbol",
        "total_supply",
        "price_per_token",
      ]);

      if (isValid) {
        setStep(2);
      }
      return;
    }

    // Step 2 validation - Investment Details
    if (step === 2) {
      const isValid = await form.trigger([
        "target_raise",
        "minimum_raise",
        "min_investment",
        "investment_window_days",
      ]);

      if (isValid) {
        setStep(3);
      }
      return;
    }

    // Step 3 validation - Use of Funds
    if (step === 3) {
      const totalPercentage = useOfFunds.reduce((sum, a) => sum + a.percentage, 0);
      const totalAmount = useOfFunds.reduce((sum, a) => sum + a.amount_ngn, 0);

      if (useOfFunds.length === 0) {
        toast.error("Please add at least one fund allocation category");
        return;
      }

      if (Math.abs(totalPercentage - 100) >= 0.01) {
        toast.error("Total allocation must equal 100%");
        return;
      }

      if (Math.abs(totalAmount - targetRaise) >= 1) {
        toast.error(`Total amount must equal â‚¦${targetRaise.toLocaleString()}`);
        return;
      }

      setStep(4);
      return;
    }
  };
  
  const prevStep = () => {
    if (step === 1) {
      setStep(0);
    } else {
      setStep(step - 1);
    }
  };

  const onSubmit = (data: TokenizationForm) => {
    console.log("ðŸš¨ onSubmit called with step:", step);
    
    if (step !== 4) {
      console.log("ðŸš¨ BLOCKED - not on final step. Current step:", step);
      toast.error(`Cannot submit on step ${step}. Please complete all steps first.`);
      return;
    }
    
    if (!isAuthenticated || !user?.id) {
      toast.error("Please log in to continue.");
      return;
    }
    if (!property || property.owner_id !== user.id) {
      toast.error("You can only tokenize your own property.");
      return;
    }
    
    console.log("ðŸš€ Creating tokenization...");
    createTokenizationMutation.mutate(data);
  };

  if (propertyLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto">
          <div className="animate-pulse space-y-4">
            <div className="h-8 bg-muted rounded w-1/3"></div>
            <div className="h-4 bg-muted rounded w-2/3"></div>
            <div className="h-64 bg-muted rounded"></div>
          </div>
        </div>
      </div>
    );
  }

  if (!property) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto text-center">
          <h1 className="text-2xl font-bold mb-4">Property Not Found</h1>
          <Button onClick={() => navigate("/property/management")}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Properties
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-4xl mx-auto">
        {/* Step indicator */}
        <div className="mb-8">
          <Progress value={(step / 4) * 100} className="h-2" />
          <div className="mt-2 text-sm text-muted-foreground">
            Step {step + 1} of 5
          </div>
        </div>

        {/* Property Details Card */}
        <Card className="mb-6">
          <CardContent className="p-6">
            <div className="flex items-center gap-6">
              {/* Property Image */}
              <div className="flex-shrink-0">
                <div className="w-24 h-24 rounded-lg bg-muted flex items-center justify-center overflow-hidden">
                  {property.property_images?.[0] ? (
                    <img
                      src={property.property_images[0].image_url}
                      alt={property.title}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <Building className="h-10 w-10 text-muted-foreground" />
                  )}
                </div>
              </div>

              {/* Property Info */}
              <div className="flex-1 min-w-0">
                <h3 className="text-lg font-semibold truncate">{property.title}</h3>
                <p className="text-sm text-muted-foreground truncate">
                  {(property.location as any)?.city}, {(property.location as any)?.state}
                </p>
              </div>

              {/* Financial Info */}
              <div className="flex gap-6 flex-shrink-0">
                <div className="text-right">
                  <p className="text-xs text-muted-foreground">Monthly Rental</p>
                  <p className="text-lg font-semibold">
                    â‚¦{(property.rental_income_monthly || 0).toLocaleString()}
                  </p>
                </div>
                <Separator orientation="vertical" className="h-12" />
                <div className="text-right">
                  <p className="text-xs text-muted-foreground">Property Value</p>
                  <p className="text-lg font-semibold">
                    â‚¦{(property.estimated_value || 0).toLocaleString()}
                  </p>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* Step 0: Type Selection */}
            {step === 0 && (
              <div className="space-y-6">
                <div className="text-center">
                  <h2 className="text-2xl font-bold mb-2">Select Tokenization Type</h2>
                  <p className="text-muted-foreground">
                    Choose how investors will participate in your property
                  </p>
                </div>

                <div className="grid md:grid-cols-3 gap-4">
                  {tokenizationTypes.map((type) => (
                    <HoverCard key={type.id} openDelay={150} closeDelay={100}>
                      <HoverCardTrigger asChild>
                        <Card
                          className={`cursor-pointer transition-all hover:shadow-lg ${
                            selectedType === type.id ? "ring-2 ring-primary" : ""
                          }`}
                          onClick={() => handleTypeSelection(type.id)}
                        >
                          <CardContent className="p-6">
                            <div className="flex flex-col items-center text-center space-y-4">
                              <type.icon className="h-12 w-12 text-primary" />
                              <div>
                                <h3 className="font-semibold">{type.title}</h3>
                                <p className="text-sm text-muted-foreground mt-1">
                                  {type.description}
                                </p>
                              </div>
                              <Badge variant="secondary">{type.badge}</Badge>
                            </div>
                          </CardContent>
                        </Card>
                      </HoverCardTrigger>
                      <HoverCardContent align="center" className="w-80">
                        <div className="space-y-2 text-sm">
                          <p><span className="font-medium">Structure:</span> {type.details.structure}</p>
                          <p><span className="font-medium">Returns:</span> {type.details.returns}</p>
                          <p><span className="font-medium">Risk:</span> {type.details.risk}</p>
                          <p><span className="font-medium">Rights:</span> {type.details.rights}</p>
                          <p><span className="font-medium">Example:</span> {type.details.example}</p>
                          <p className="text-primary font-medium">Limit: {type.details.maxRaise}</p>
                        </div>
                      </HoverCardContent>
                    </HoverCard>
                  ))}
                </div>
              </div>
            )}

            {/* Step 1: Basic Information */}
            {step === 1 && (
              <div className="space-y-6">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold mb-2">Basic Token Information</h2>
                  <p className="text-muted-foreground">
                    Configure your token details
                  </p>
                </div>

                <Card>
                  <CardContent className="pt-6 space-y-4">
                    <FormField
                      control={form.control}
                      name="token_name"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Token Name</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="e.g., Luxury Villa Token" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="token_symbol"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Token Symbol</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="e.g., LVILLA" maxLength={10} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="grid grid-cols-2 gap-4">
                      <FormField
                        control={form.control}
                        name="total_supply"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Total Supply</FormLabel>
                            <FormControl>
                              <Input
                                type="text"
                                inputMode="numeric"
                                value={form.watch("total_supply") ? form.watch("total_supply").toLocaleString() : ""}
                                onChange={(e) => {
                                  const raw = e.target.value.replace(/,/g, "");
                                  const num = parseFloat(raw);
                                  field.onChange(isNaN(num) ? 0 : num);
                                }}
                                onFocus={(e) => e.target.select()}
                                placeholder="e.g., 10,000"
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="price_per_token"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Price per Token (â‚¦)</FormLabel>
                            <FormControl>
                              <MoneyInput
                                value={field.value}
                                onChange={(v) => field.onChange(v)}
                                placeholder="e.g., 1,000"
                                currency="â‚¦"
                                min={0.01}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    {maxPossibleRaise > 0 && (
                        <div className="p-4 bg-muted rounded-lg space-y-1">
                          <p className="text-sm font-medium">
                            Maximum Possible Raise: â‚¦{maxPossibleRaise.toLocaleString()}
                          </p>
                          <p className="text-xs text-muted-foreground">
                            Per-type cap (supply Ã— price): â‚¦{Math.floor(typeMaxTotalValue).toLocaleString()} â€” {typeRuleText}
                          </p>
                        </div>
                    )}
                  </CardContent>
                </Card>
              </div>
            )}

            {/* Step 2: Investment Details */}
            {step === 2 && (
              <div className="space-y-6">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold mb-2">Investment Details</h2>
                  <p className="text-muted-foreground">
                    Configure investment parameters and returns
                  </p>
                </div>

                <Card>
                  <CardContent className="pt-6 space-y-6">
                    {/* Financial Targets */}
                    <div className="space-y-4">
                      <h3 className="font-semibold">Financial Targets</h3>
                      <div className="grid grid-cols-2 gap-4">
                        <FormField
                          control={form.control}
                          name="target_raise"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Target Raise (â‚¦)</FormLabel>
                              <FormControl>
                                <MoneyInput
                                  value={field.value}
                                  onChange={(v) => field.onChange(v)}
                                  placeholder="e.g., 5,000,000"
                                  currency="â‚¦"
                                  min={1}
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={form.control}
                          name="minimum_raise"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Minimum Raise (â‚¦)</FormLabel>
                              <FormControl>
                                <MoneyInput
                                  value={field.value}
                                  onChange={(v) => field.onChange(v)}
                                  placeholder="e.g., 1,500,000"
                                  currency="â‚¦"
                                  min={1}
                                />
                              </FormControl>
                              <FormDescription>Offering fails if not met</FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>
                    </div>

                    <Separator />

                    {/* Investment Limits */}
                    <div className="space-y-4">
                      <h3 className="font-semibold">Investment Limits</h3>
                      <div className="grid grid-cols-2 gap-4">
                        <FormField
                          control={form.control}
                          name="min_investment"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Minimum Investment (â‚¦)</FormLabel>
                              <FormControl>
                                <MoneyInput
                                  value={field.value}
                                  onChange={(v) => field.onChange(v)}
                                  placeholder="e.g., 10,000"
                                  currency="â‚¦"
                                  min={1}
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={form.control}
                          name="max_investment"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Maximum Investment (â‚¦)</FormLabel>
                              <FormControl>
                                <MoneyInput
                                  value={field.value || 0}
                                  onChange={(v) => field.onChange(v)}
                                  placeholder="e.g., 1,000,000"
                                  currency="â‚¦"
                                  min={1}
                                />
                              </FormControl>
                              <FormDescription>Optional cap per investor</FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>
                    </div>

                    <Separator />

                    {/* Investment Window */}
                    <div className="space-y-4">
                      <h3 className="font-semibold">Investment Window</h3>
                      <FormField
                        control={form.control}
                        name="investment_window_days"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Duration (Days)</FormLabel>
                            <FormControl>
                              <Input
                                type="text"
                                inputMode="numeric"
                                value={field.value ? field.value.toLocaleString() : ""}
                                onChange={(e) => {
                                  const raw = e.target.value.replace(/,/g, "");
                                  const num = parseInt(raw);
                                  field.onChange(isNaN(num) ? 0 : num);
                                }}
                                onFocus={(e) => e.target.select()}
                                placeholder="e.g., 30"
                              />
                            </FormControl>
                            <FormDescription>
                              Number of days the investment window will remain open
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <Separator />

                    {/* Returns & Distribution */}
                    <div className="space-y-4">
                      <h3 className="font-semibold">Returns & Distribution</h3>
                      
                      {selectedType === "debt" && (
                        <Alert>
                          <Info className="h-4 w-4" />
                          <AlertDescription>
                            For debt tokenization, expected ROI represents the fixed interest rate.
                          </AlertDescription>
                        </Alert>
                      )}

                      {selectedType === "revenue" && (
                        <Alert>
                          <Info className="h-4 w-4" />
                          <AlertDescription>
                            Revenue sharing tokens distribute a percentage of gross rental income.
                          </AlertDescription>
                        </Alert>
                      )}

                      <div className="grid grid-cols-2 gap-4">
                        <FormField
                          control={form.control}
                          name="expected_roi_annual"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Expected Annual ROI (%)</FormLabel>
                              <FormControl>
                                <Input
                                  type="number"
                                  step="0.1"
                                  value={field.value || ""}
                                  onChange={(e) => {
                                    const val = parseFloat(e.target.value);
                                    field.onChange(isNaN(val) ? 0 : val);
                                  }}
                                  onFocus={(e) => e.target.select()}
                                  placeholder="e.g., 8.5"
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={form.control}
                          name="dividend_frequency"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Dividend Frequency</FormLabel>
                              <Select onValueChange={field.onChange} value={field.value}>
                                <FormControl>
                                  <SelectTrigger>
                                    <SelectValue placeholder="Select frequency" />
                                  </SelectTrigger>
                                </FormControl>
                                <SelectContent>
                                  <SelectItem value="monthly">Monthly</SelectItem>
                                  <SelectItem value="quarterly">Quarterly</SelectItem>
                                  <SelectItem value="annually">Annually</SelectItem>
                                </SelectContent>
                              </Select>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>
                    </div>

                    <Separator />

                    {/* Fees & Controls */}
                    <div className="space-y-4">
                      <h3 className="font-semibold">Fees & Controls</h3>
                      <div className="grid grid-cols-2 gap-4">
                        <FormField
                          control={form.control}
                          name="management_fee_percentage"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Management Fee (%)</FormLabel>
                              <FormControl>
                                <Input
                                  type="number"
                                  step="0.1"
                                  value={field.value || ""}
                                  disabled
                                  className="bg-muted cursor-not-allowed"
                                  placeholder="e.g., 2.5"
                                />
                              </FormControl>
                              <FormDescription className="text-xs">
                                Set based on tokenization type
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={form.control}
                          name="platform_fee_percentage"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Platform Fee (%)</FormLabel>
                              <FormControl>
                                <Input
                                  type="number"
                                  step="0.1"
                                  value={field.value || ""}
                                  disabled
                                  className="bg-muted cursor-not-allowed"
                                  placeholder="e.g., 1.0"
                                />
                              </FormControl>
                              <FormDescription className="text-xs">
                                Standard platform fee (fixed)
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>

                      <FormField
                        control={form.control}
                        name="auto_refund"
                        render={({ field }) => (
                          <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                            <div className="space-y-0.5">
                              <FormLabel className="text-base">Auto-Refund</FormLabel>
                              <FormDescription>
                                Automatically refund investors if minimum raise is not met
                              </FormDescription>
                            </div>
                            <FormControl>
                              <Switch
                                checked={field.value}
                                onCheckedChange={field.onChange}
                              />
                            </FormControl>
                          </FormItem>
                        )}
                      />
                    </div>

                    <Separator />

                    {/* Token Purchase Limits (Optional) */}
                    <Collapsible>
                      <CollapsibleTrigger asChild>
                        <Button variant="ghost" className="w-full justify-between">
                          <span className="font-semibold">Advanced: Token Purchase Limits</span>
                          <ChevronRight className="h-4 w-4" />
                        </Button>
                      </CollapsibleTrigger>
                      <CollapsibleContent className="space-y-4 pt-4">
                        <div className="grid grid-cols-2 gap-4">
                          <FormField
                            control={form.control}
                            name="min_tokens_per_purchase"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Min Tokens per Purchase</FormLabel>
                                <FormControl>
                                  <Input
                                    type="text"
                                    inputMode="numeric"
                                    value={field.value ? field.value.toLocaleString() : ""}
                                    onChange={(e) => {
                                      const raw = e.target.value.replace(/,/g, "");
                                      const num = parseInt(raw);
                                      field.onChange(isNaN(num) ? 0 : num);
                                    }}
                                    onFocus={(e) => e.target.select()}
                                    placeholder="e.g., 1"
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={form.control}
                            name="max_tokens_per_purchase"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Max Tokens per Purchase</FormLabel>
                                <FormControl>
                                  <Input
                                    type="text"
                                    inputMode="numeric"
                                    value={field.value ? field.value.toLocaleString() : ""}
                                    onChange={(e) => {
                                      const raw = e.target.value.replace(/,/g, "");
                                      const num = parseInt(raw);
                                      field.onChange(isNaN(num) ? 0 : num);
                                    }}
                                    onFocus={(e) => e.target.select()}
                                    placeholder="e.g., 1,000"
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </div>
                      </CollapsibleContent>
                    </Collapsible>

                    {/* Helpful Calculations */}
                    {targetRaise > 0 && pricePerToken > 0 && form.watch("min_investment") > 0 && (
                      <div className="p-4 bg-muted rounded-lg space-y-2">
                        <div className="flex justify-between text-sm">
                          <span>Min raise requires:</span>
                          <span className="font-medium">
                            {Math.ceil(form.watch("minimum_raise") / pricePerToken).toLocaleString()} tokens
                          </span>
                        </div>
                        <div className="flex justify-between text-sm">
                          <span>Target raise requires:</span>
                          <span className="font-medium">
                            {Math.ceil(targetRaise / pricePerToken).toLocaleString()} tokens
                          </span>
                        </div>
                        {form.watch("max_investment") && (
                          <div className="flex justify-between text-sm">
                            <span>Estimated investor range:</span>
                            <span className="font-medium">
                              {Math.ceil(form.watch("minimum_raise") / form.watch("max_investment")!)} -{" "}
                              {Math.floor(targetRaise / form.watch("min_investment"))} investors
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                  </CardContent>
                </Card>
              </div>
            )}

            {/* Step 3: Use of Funds */}
            {step === 3 && (
              <div className="space-y-6">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold mb-2">Use of Funds</h2>
                  <p className="text-muted-foreground">
                    Specify how the raised funds will be allocated
                  </p>
                </div>

                <FundAllocationBuilder
                  tokenizationType={selectedType}
                  targetRaise={targetRaise || 0}
                  value={useOfFunds}
                  onChange={setUseOfFunds}
                />

                {useOfFunds.length > 0 && (
                  <UseOfFundsChart data={useOfFunds} targetRaise={targetRaise || 0} />
                )}
              </div>
            )}

            {/* Step 4: Terms & Submit */}
            {step === 4 && (
              <TokenizationTermsAcceptance
                tokenizationType={selectedType}
                tokenName={form.watch("token_name")}
                totalSupply={form.watch("total_supply")}
                useOfFunds={useOfFunds}
                targetRaise={targetRaise || 0}
                onAccept={handleTermsAccept}
                onDecline={handleTermsDecline}
                isSubmitting={createTokenizationMutation.isPending}
              />
            )}

            {/* Navigation Buttons */}
            {step < 4 && (
              <div className="flex justify-between">
                {step > 0 && (
                  <Button type="button" variant="outline" onClick={prevStep}>
                    <ChevronLeft className="h-4 w-4 mr-2" />
                    Back
                  </Button>
                )}
                <Button
                  type="button"
                  onClick={nextStep}
                  className={step === 0 ? "ml-auto" : ""}
                >
                  Continue
                  <ChevronRight className="h-4 w-4 ml-2" />
                </Button>
              </div>
            )}
          </form>
        </Form>
      </div>
    </div>
  );
};

export default TokenizeProperty;
